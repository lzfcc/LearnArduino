# Bad Apple 播放

## 串口通信

### 步骤

1. 下载 Bad Apple 视频

2. 下载 [ffmpeg](https://www.ffmpeg.org/)并处理视频

将视频尺寸缩小。原视频比例为 4 : 3，M5StickC 屏幕为 160 x 80，所以选择将视频尺寸缩小为 96 x 72，正好都是整字节数。

然后将视频按照 6 帧/秒提取帧。(这个选择没有什么依据，理论上越大播放越流畅，但是受限于~~屏幕的刷新频率~~波特率以及屏幕的刷新速度)
```shell
$ ffmpeg -i badapple.mp4 -s 96x72 smallapple.mp4 
$ ffmpeg -i smallapple.mp4 -r 6 image-%04d.jpg
```

3. 下载 image2lcd（Windows）将图片转为二进制

注意勾选“字节内像素数据反序”，不要勾选“包含图像头数据”，否则显式异常。如果将数据写在闪存里（`setup()`时），输出数据类型适合于勾选“C 语言数组(.c)”（在 Arduino 中用 .h 文件引入），否则勾选“二进制(.bin)”。

4. 编写 Arduino 程序

仿照 M5StickC 示例中的 Advanced -> Display -> DrawXBitmap。注意这里并非使用`drawBitmap`而是`drawXBitMap`。前者可以绘制 16 位深的彩色图像，而后者是用来绘制二值图像的（X Bitmap）。

[X Bitmap](https://en.wikipedia.org/wiki/X_BitMap)是一种很古早的图像格式，它本身实际上就是一段 C 代码（图像宽高和数据的一维数组定义）。它用 1 个 bit 代表 1 个像素，所以只有 0/1 两个值。位于图像左上角的像素在数组中用第 1 个元素的最低位表示。（所以要勾选“字节内像素反序”）

`setup()`中绘制一些静态的装饰性内容，`loop()`中绘制串口数据。

5. 编写串口通信程序（communication.py）

使用 python 2.7 和 serial（需要安装）。按顺序读取图像二进制文件然后发送到串口即可。

### 存在的问题

1. 画面闪动频繁

闪动原因是
```c
M5.Lcd.drawXBitmap(60, 0, image, videoWidth, videoHeight, TFT_BLACK, TFT_BLACK);
M5.Lcd.drawXBitmap(60, 0, image, videoWidth, videoHeight, TFT_WHITE, TFT_BLACK);     
```
先用全黑的图像“擦除了前一帧”，然后再绘制。

2. 必须通过串口通信，无法脱离电脑
3. 只能播放二值图像。[彩色图像](../hop)经过实验，发现传输太慢（猜测瓶颈是波特率，因为 Truc Color 彩图一帧的数据量太大，大约 142 * 80 * 2 = 22 kB）。

### 解决方案

~~1. “局部更新”，计算相邻两帧图像的差异（异或操作）~~
1. 根本不需要“擦除”，直接绘制即可。

2. 压缩视频，写入 flash 存储脱机播放；可以进一步尝试使用 wifi 等方式播放

有关于压缩算法，上网查了一下，有人推荐使用 [LZO](https://en.wikipedia.org/wiki/Lempel%E2%80%93Ziv%E2%80%93Oberhumer)，有现成的[开源库](http://www.oberhumer.com/opensource/lzo/)可以用。开源库的优点都有啥？

- LZO 是一个用 ANSI C 编写的便携式**无损数据压缩库**。
- 提供非常快的压缩和**极其**快速减压。
- 最快的压缩和解压缩算法。
- 包含能达到相当高压缩比的慢压缩等级，同时解压缩速度非常快。

注意其中的 miniLZO 的简介：
> miniLZO 是 LZO 库的一个十分轻量级的子集，在你自己的应用中可以轻松地引入。 它是从 LZO 源码自动生成的，包含了 LZO 最重要的功能。

可见非常适用于这个项目的场景。每一帧是 96 * 72 / 8  = 864 B，一共 1000+ 帧，所以如果把数据全部写入闪存需要接近 1 MB，而每个程序的存储空间必须限制在 1280 kB，非常紧张。我们将压缩后的数据写入闪存，然后逐帧解压缩即可。

我下载了 miniLZO 代码，并建好了 XCode 工程（`../minilzo/`）。我们只需要压缩的部分，而解压的部分放在 M5StickC 中。具体步骤：

（1）用 minilzo 压缩之前放在`frames/`目录下的二进制帧数据，写文件生成一个`.h`文件。注意因为全部数据都在一个一位数组里，所以还需要额外一个数组记录每一帧的字节数。实验表明，数据压缩到了原大小的 32%。
（真棒，这里复习了一下 C 语言读写文件的 API……）

（2）将 minilzo 全部代码拷贝到 M5StickC 项目中，去除`testmini.c`中除解压代码。代码量很大，而且有很多是为了兼容不同平台的宏定义，虽然我很想清理一下，但是一改就错，所以就这样吧……

代码中有这么一行：
```c
static HEAP_ALLOC(wrkmem, LZO1X_1_MEM_COMPRESS);
```

是用于压缩的 buffer（16 kB）。因为单片机这边不需要压缩数据，所以这一行没有用，要去掉。即便有用，这句也无法编译通过（错误：申请堆内存过多），可能需要用栈内存代替（？）。

另外，`IN_LEN`也不必`128*1024ul`这么多，可以根据要压缩的数据量灵活定义。

现在，M5StickC 可以离线循环播放 Bad Apple 了！（而且真的很流畅，完美！）

3. 先将每一帧压缩，再通过串口传输到机器，解压缩后绘制